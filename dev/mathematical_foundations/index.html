<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Foundations · QuantumMeasurements.jl</title><meta name="title" content="Mathematical Foundations · QuantumMeasurements.jl"/><meta property="og:title" content="Mathematical Foundations · QuantumMeasurements.jl"/><meta property="twitter:title" content="Mathematical Foundations · QuantumMeasurements.jl"/><meta name="description" content="Documentation for QuantumMeasurements.jl."/><meta property="og:description" content="Documentation for QuantumMeasurements.jl."/><meta property="twitter:description" content="Documentation for QuantumMeasurements.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QuantumMeasurements.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumMeasurements.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick-Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../twin_photons_pvm/">Twin Photons</a></li><li><a class="tocitem" href="../twin_photons_prop/">Twin photons with proportional measurement</a></li><li><a class="tocitem" href="../spatial_structure/">Spatial structure of light</a></li><li><a class="tocitem" href="../obstructed_spatial_structure/">Spatial structure of light with obstructions</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../random_states/">Random State Generation</a></li><li class="is-active"><a class="tocitem" href>Mathematical Foundations</a><ul class="internal"><li><a class="tocitem" href="#Quantum-State-Tomography"><span>Quantum State Tomography</span></a></li><li><a class="tocitem" href="#Observables-and-Measurements"><span>Observables and Measurements</span></a></li><li><a class="tocitem" href="#Parameterization-of-States"><span>Parameterization of States</span></a></li><li><a class="tocitem" href="#linear_inversion"><span>Linear Inversion estimator</span></a></li><li><a class="tocitem" href="#Other-estimation-Methods"><span>Other estimation Methods</span></a></li><li><a class="tocitem" href="#Advanced-Estimation-Methods"><span>Advanced Estimation Methods</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../maximum_likelihood/">Maximum Likelihood Estimation</a></li><li><a class="tocitem" href="../bayesian_inference/">Bayesian Inference</a></li><li><a class="tocitem" href="../proportional_measurements/">Proportional Measurements</a></li></ul></li><li><span class="tocitem">How-to Guides</span><ul><li><a class="tocitem" href="../choosing_methods/">Choosing Estimation Methods</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theory</a></li><li class="is-active"><a href>Mathematical Foundations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical Foundations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/marcsgil/QuantumMeasurements.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/marcsgil/QuantumMeasurements.jl/blob/master/docs/src/mathematical_foundations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-Foundations"><a class="docs-heading-anchor" href="#Mathematical-Foundations">Mathematical Foundations</a><a id="Mathematical-Foundations-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Foundations" title="Permalink"></a></h1><p>This section provides the mathematical foundations of quantum state tomography that underpin the methods implemented in QuantumMeasurements.jl.</p><h2 id="Quantum-State-Tomography"><a class="docs-heading-anchor" href="#Quantum-State-Tomography">Quantum State Tomography</a><a id="Quantum-State-Tomography-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-State-Tomography" title="Permalink"></a></h2><p>Let <span>$\mathcal{H}$</span> be a Hilbert space of dimension <span>$d$</span>, and let <span>$\mathrm{Her}(\mathcal{H}) \subset \mathcal{H}$</span> be the set of Hermitian operators acting on <span>$\mathcal{H}$</span>. The state of a quantum system is represented by an element <span>$\rho$</span> of the set of positive semi-definite operators <span>$\mathrm{Pos}(\mathcal{H}) \subset \mathrm{Her}(\mathcal{H})$</span> such that <span>$\mathrm{Tr} \rho = 1$</span>. Quantum state tomography is the process of reconstructing the density operator <span>$\rho$</span> from experimental data.</p><h2 id="Observables-and-Measurements"><a class="docs-heading-anchor" href="#Observables-and-Measurements">Observables and Measurements</a><a id="Observables-and-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Observables-and-Measurements" title="Permalink"></a></h2><p>Observables are represented by elements <span>$A \in \mathrm{Her}(\mathcal{H})$</span>, and their expectation values are given by:</p><p class="math-container">\[\langle A \rangle = \mathrm{Tr} \left(\rho A\right)\]</p><p>A Positive Operator Valued Measure (POVM) is a set of observables <span>$\{\Pi_m\} \subset \mathrm{Pos}(\mathcal{H})$</span> with the property that:</p><p class="math-container">\[\sum_m \Pi_m = \mathbb{1}\]</p><p>where <span>$\mathbb{1}$</span> is the identity operator. These operators model the possible outcomes of an experiment: outcome <span>$m$</span> happens with probability <span>$p_m = \mathrm{Tr} \left(\Pi_m \rho \right)$</span> according to Born&#39;s rule. The POVM conditions ensure that <span>$p_m \geq 0$</span> and <span>$\sum_m p_m = 1$</span>.</p><p>A special case of a POVM is a projective measurement (PVM), where each <span>$\Pi_m$</span> is a projector, i.e., <span>$\Pi_m = |u_m\rangle\langle u_m|$</span> for some basis vector <span>$|u_m\rangle \in \mathcal{H}$</span>.</p><h2 id="Parameterization-of-States"><a class="docs-heading-anchor" href="#Parameterization-of-States">Parameterization of States</a><a id="Parameterization-of-States-1"></a><a class="docs-heading-anchor-permalink" href="#Parameterization-of-States" title="Permalink"></a></h2><p>Usually, one chooses a specific basis for the Hilbert space <span>$\mathcal{H}$</span> to represent the state <span>$\rho$</span>, say <span>$\{|u_1\rangle, \ldots, |u_d\rangle\}$</span>. The density operator can then be expressed in terms of the basis vectors as:</p><p class="math-container">\[\rho = \sum_{j,k=1}^{d} \rho_{jk} |u_j\rangle\langle u_k|\]</p><p>where <span>$\rho_{jk} = \langle u_j | \rho | u_k \rangle$</span> are the matrix elements of <span>$\rho$</span> in this basis.</p><p>Nonetheless, this matrix representation is redundant because <span>$\rho$</span> is Hermitian and has unit trace. This means that only <span>$d^2 - 1$</span> independent real parameters are needed to specify <span>$\rho$</span>. We can choose a traceless basis of Hermitian operators to represent the state uniquely. A convenient choice is the generalized Gell-Mann matrices, which come in three types:</p><p class="math-container">\[\begin{aligned}
X_{jk} &amp;= \frac{|u_j\rangle\langle u_k| + |u_k\rangle\langle u_j|}{\sqrt{2}} \\
Y_{jk} &amp;= \frac{i(|u_j\rangle\langle u_k| - |u_k\rangle\langle u_j|)}{\sqrt{2}} \\
Z_j &amp;= \frac{1}{\sqrt{j + j^2}} \left( \sum_{r=1}^j |u_r\rangle\langle u_r| - j |u_{j+1}\rangle\langle u_{j+1}| \right)
\end{aligned}\]</p><p>where <span>$j = 1, \ldots, d-1$</span>, <span>$k = j+1, \ldots, d$</span>, and <span>$\{|u_1\rangle, \ldots, |u_d\rangle\}$</span> is our chosen basis set of <span>$\mathcal{H}$</span>. The type <a href="../api/#QuantumMeasurements.GellMannMatrices"><code>GellMannMatrices</code></a> is an iterator over these matrices.</p><p>We can specify any state <span>$\rho$</span> by a list of real coefficients <span>$\boldsymbol{\theta} = (\theta_1,\ldots,\theta_{d^2-1})$</span> such that:</p><p class="math-container">\[\rho = \rho(\boldsymbol{\theta}) = \frac{\mathbb{1}}{d} + \sum_{n=1}^{d^2-1} \theta_n \omega_n \qquad (1)\]</p><p>where <span>$\omega_n$</span> denotes one of the generalized Gell-Mann matrices. The vector <span>$\boldsymbol{\theta}$</span> is called the generalized Bloch vector. The Bloch vector can be calculated from the matrix <span>$\rho$</span> using the function <a href="../api/#QuantumMeasurements.traceless_vectorization"><code>traceless_vectorization</code></a>. Reciprocally, the density matrix can be reconstructed from the Bloch vector using <a href="../api/#QuantumMeasurements.density_matrix_reconstruction"><code>density_matrix_reconstruction</code></a>.</p><h2 id="linear_inversion"><a class="docs-heading-anchor" href="#linear_inversion">Linear Inversion estimator</a><a id="linear_inversion-1"></a><a class="docs-heading-anchor-permalink" href="#linear_inversion" title="Permalink"></a></h2><p>By applying <span>$\mathrm{Tr} (\Pi_m \bullet)$</span> to both sides of equation (1), we arrive at the linear system:</p><p class="math-container">\[\mathbf{q} = T \boldsymbol{\theta}\]</p><p>where <span>$q_m = p_m - \mathrm{Tr} \Pi_m / d$</span> and <span>$T$</span> is a matrix with entries <span>$T_{mn} = \mathrm{Tr} \left(\Pi_m \omega_n \right)$</span>.</p><p>If the matrix <span>$T$</span> is injective, the linear system has a unique solution given by:</p><p class="math-container">\[\boldsymbol{\theta} = (T^\dagger T)^{-1} T^\dagger\boldsymbol{q} \qquad (2)\]</p><p>In this case, the POVM is said to be <strong>informationally complete</strong>. Otherwise, if <span>$T$</span> is not injective, the solution is no longer unique and the POVM is said to be informationally incomplete.</p><p>This defines the simplest measurement type in our package: given an iterable representing a measurement (each element of the iterable must be a matrix representing the POVM element, or a vector. In the latter case, the vector is interpreted as a projector). Then one calls <a href="../api/#QuantumMeasurements.assemble_measurement_matrix-Tuple{Any}"><code>assemble_measurement_matrix</code></a> to construct the matrix <span>$T$</span>. This is passed to the functions that perform the tomography.</p><p>This would then be the simplest application of our package:</p><pre><code class="language-julia hljs">itr = ... # an iterable of matrices or vectors representing the POVM elements
probs = ... # a vector of probabilities corresponding to the outcomes of the measurement

μ = assemble_measurement_matrix(itr) # assemble the measurement matrix T
ρ, θ = estimate_state(probs, μ, LinearInversion()) # estimate the state (both the density matrix and the Bloch vector)</code></pre><p>It is important to observe that the probabilities in the inversion formula (2) are not directly measurable and must be estimated. The simplest method substitutes them with observed experimental frequencies <span>$\hat{p}_m = N_m / N$</span>, where <span>$N_m$</span> is the number of times outcome <span>$m$</span> was observed and <span>$N = \sum_m N_m$</span> is the total number of observations. This estimation of the probabilities is inherently noisy, due to finite number of observations or experimental imperfections, which can lead to inaccuracies in the reconstructed state. Most importantly, it might be the case that the state reconstructed from the estimated probabilities is not a valid density matrix, i.e., it may not be positive semi-definite. Therefore, the <a href="../api/#QuantumMeasurements.estimate_state"><code>estimate_state</code></a> function will apply an algorithm to project the reconstructed state onto the closest valid density matrix [<a href="../references/#smolin_efficient_2012">2</a>], ensuring that the output is always a valid quantum state.</p><h2 id="Other-estimation-Methods"><a class="docs-heading-anchor" href="#Other-estimation-Methods">Other estimation Methods</a><a id="Other-estimation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-estimation-Methods" title="Permalink"></a></h2><h3 id="Variants-of-Linear-Inversion"><a class="docs-heading-anchor" href="#Variants-of-Linear-Inversion">Variants of Linear Inversion</a><a id="Variants-of-Linear-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Variants-of-Linear-Inversion" title="Permalink"></a></h3><p>While the basic linear inversion approach provides a straightforward solution to quantum state tomography, different computational strategies can be employed depending on the specific requirements of the problem. The package implements three variants of linear inversion, each with distinct advantages and trade-offs.</p><h4 id="LinearInversion"><a class="docs-heading-anchor" href="#LinearInversion">LinearInversion</a><a id="LinearInversion-1"></a><a class="docs-heading-anchor-permalink" href="#LinearInversion" title="Permalink"></a></h4><p>The standard <a href="../api/#QuantumMeasurements.LinearInversion"><code>LinearInversion</code></a> method solves the linear system <span>$T \boldsymbol{\theta} = \boldsymbol{q}$</span> directly using QR decomposition via Julia&#39;s <a href="https://docs.julialang.org/en/v1/base/math/"><code>\</code></a> operator. This is the most straightforward implementation that solves the system without explicitly computing matrix inverses.</p><p><strong>Theory</strong>: The method solves the linear system <span>$T \boldsymbol{\theta} = \boldsymbol{q}$</span> directly using QR decomposition, which provides a numerically stable least-squares solution for overdetermined systems.</p><p><strong>Motivation</strong>: This approach is ideal for single-shot tomography or when the measurement setup changes between different state estimations. It requires no preprocessing and is numerically stable due to the QR decomposition.</p><p><strong>Pros</strong>: </p><ul><li>Simple and robust implementation</li><li>No memory overhead for preprocessing</li><li>Numerically stable via QR decomposition</li><li>Suitable for one-time or infrequent state estimations</li></ul><p><strong>Cons</strong>:</p><ul><li>Computational overhead for repeated estimations with the same measurement</li><li>Slower than optimized variants for multiple estimations</li></ul><h4 id="PreAllocatedLinearInversion"><a class="docs-heading-anchor" href="#PreAllocatedLinearInversion">PreAllocatedLinearInversion</a><a id="PreAllocatedLinearInversion-1"></a><a class="docs-heading-anchor-permalink" href="#PreAllocatedLinearInversion" title="Permalink"></a></h4><p>The <a href="../api/#QuantumMeasurements.PreAllocatedLinearInversion"><code>PreAllocatedLinearInversion</code></a> method precomputes the pseudoinverse <span>$T^+$</span> of the measurement matrix during initialization, storing it for subsequent state estimations. This eliminates the need to solve the linear system repeatedly.</p><p><strong>Theory</strong>: By precomputing <span>$T^+$</span>, the state estimation reduces to a simple matrix-vector multiplication: <span>$\boldsymbol{\theta} = T^+ \boldsymbol{q}$</span>, where <span>$\boldsymbol{q}$</span> is adjusted for the trace part.</p><p><strong>Motivation</strong>: This variant is designed for scenarios where many state estimations are performed using the same measurement setup, such as real-time tomography.</p><p><strong>Pros</strong>:</p><ul><li>Significant speedup for repeated estimations</li><li>Predictable computational cost per estimation</li><li>Optimal for batch processing or real-time applications</li></ul><p><strong>Cons</strong>:</p><ul><li>Memory overhead for storing the precomputed pseudoinverse</li><li>Requires reinitialization if the measurement setup changes</li><li>Initial setup cost for computing the pseudoinverse</li></ul><h4 id="NormalEquations"><a class="docs-heading-anchor" href="#NormalEquations">NormalEquations</a><a id="NormalEquations-1"></a><a class="docs-heading-anchor-permalink" href="#NormalEquations" title="Permalink"></a></h4><p>The <a href="../api/#QuantumMeasurements.NormalEquations"><code>NormalEquations</code></a> method solves the normal equations <span>$T^\dagger T \boldsymbol{\theta} = T^\dagger \boldsymbol{q}$</span> directly, which can be computationally advantageous when the number of measurements is much larger than the number of parameters.</p><p><strong>Theory</strong>: Instead of computing the pseudoinverse, this method forms the normal equations explicitly: <span>$(T^\dagger T) \boldsymbol{\theta} = T^\dagger \boldsymbol{q}$</span>. The system matrix is square and typically smaller than the original overdetermined system.</p><p><strong>Motivation</strong>: For measurements with a large number of POVM elements (large <span>$M$</span>) relative to the Hilbert space dimension, solving the normal equations can be more efficient than direct pseudoinverse computation.</p><p><strong>Pros</strong>:</p><ul><li>Efficient for overcomplete measurements (large <span>$M$</span> relative to <span>$d^2-1$</span>)</li><li>Reduced computational complexity in high-redundancy scenarios</li><li>Lower memory requirements during computation</li></ul><p><strong>Cons</strong>:</p><ul><li>Potentially less numerically stable than QR-based methods</li><li>Can amplify numerical errors if <span>$T^\dagger T$</span> is ill-conditioned</li><li>May not provide advantages for moderately sized problems</li></ul><h4 id="Choosing-the-Right-Variant"><a class="docs-heading-anchor" href="#Choosing-the-Right-Variant">Choosing the Right Variant</a><a id="Choosing-the-Right-Variant-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-the-Right-Variant" title="Permalink"></a></h4><p>The choice between these variants depends on the specific use case:</p><ul><li>Use <strong>LinearInversion</strong> for single estimations or when numerical stability is paramount</li><li>Use <strong>PreAllocatedLinearInversion</strong> when performing many estimations with the same measurement setup</li><li>Use <strong>NormalEquations</strong> when dealing with highly redundant measurements where <span>$M \gg d^2-1$</span></li></ul><h2 id="Advanced-Estimation-Methods"><a class="docs-heading-anchor" href="#Advanced-Estimation-Methods">Advanced Estimation Methods</a><a id="Advanced-Estimation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Estimation-Methods" title="Permalink"></a></h2><p>Beyond linear inversion, the package provides advanced methods for challenging experimental scenarios:</p><ul><li><p><strong><a href="../maximum_likelihood/#Maximum-Likelihood-Estimation">Maximum Likelihood Estimation</a></strong>: Optimal for low photon count experiments and single-photon tomography. Handles Poisson statistics correctly and always produces physical states.</p></li><li><p><strong><a href="../bayesian_inference/#Bayesian-Inference">Bayesian Inference</a></strong>: Provides full uncertainty quantification through posterior distributions. Computationally intensive but optimal for scenarios requiring error bars and handling of prior knowledge.</p></li></ul><p>For guidance on selecting the appropriate method for your experimental conditions, see <a href="../choosing_methods/#Choosing-Estimation-Methods">Choosing Estimation Methods</a>.</p><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../maximum_likelihood/#Maximum-Likelihood-Estimation">Maximum Likelihood Estimation</a>: Advanced method for low photon counts</li><li><a href="../bayesian_inference/#Bayesian-Inference">Bayesian Inference</a>: Full posterior estimation with uncertainty quantification  </li><li><a href="../proportional_measurements/#prop_meas">Proportional Measurements</a>: Handling incomplete measurements</li><li><a href="../random_states/#random_states">Random States</a>: Generating test data for validation</li><li><a href="../choosing_methods/#Choosing-Estimation-Methods">Choosing Estimation Methods</a>: Practical guide for method selection</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../random_states/">« Random State Generation</a><a class="docs-footer-nextpage" href="../maximum_likelihood/">Maximum Likelihood Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 20 July 2025 18:58">Sunday 20 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
