var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"D. F. James, P. G. Kwiat, W. J. Munro and A. G. White. Measurement of qubits. Phys. Rev. A 64, 052312 (2001).\n\n\n\nJ. A. Smolin, J. M. Gambetta and G. Smith. Efficient Method for Computing the Maximum-Likelihood Quantum State from Measurements with Additive Gaussian Noise. Physical Review Letters 108, 070502 (2012). Accessed on Jan 24, 2024. Publisher: American Physical Society.\n\n\n\nJ. Shang, Z. Zhang and H. K. Ng. Superfast maximum-likelihood reconstruction for quantum tomography. Phys. Rev. A 95, 062336 (2017).\n\n\n\nR. Blume-Kohout. Optimal, reliable estimation of quantum states. New Journal of Physics 12, 043034 (2010).\n\n\n\n","category":"page"},{"location":"choosing_methods/#Choosing-Estimation-Methods","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"This guide helps you select the appropriate quantum state tomography method for your specific experimental conditions and requirements.","category":"page"},{"location":"choosing_methods/#Quick-Decision-Tree","page":"Choosing Estimation Methods","title":"Quick Decision Tree","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Do you have complete POVM measurements?\n├─ No → Use ProportionalMeasurement wrapper and continue below\n└─ Yes → Continue below\n\nHow many photon counts do you have?\n├─ High (>1000 per setting) → Linear methods recommended\n│  ├─ Single estimation → LinearInversion\n│  ├─ Many estimations (same setup) → PreAllocatedLinearInversion  \n│  └─ Highly redundant measurements → NormalEquations\n└─ Low (<1000 per setting) → Advanced methods recommended\n   ├─ Need uncertainty quantification → BayesianInference\n   └─ Want optimal point estimate → MaximumLikelihood","category":"page"},{"location":"choosing_methods/#Method-Comparison","page":"Choosing Estimation Methods","title":"Method Comparison","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Method Speed Data Requirements Output Best For\nLinearInversion Fast High counts Point estimate General purpose, high SNR\nPreAllocatedLinearInversion Very Fast* High counts Point estimate Repeated measurements\nNormalEquations Fast High counts Point estimate Overcomplete measurements\nMaximumLikelihood Medium Any counts Point estimate Low counts, optimal accuracy\nBayesianInference Very Slow Any counts Full posterior Uncertainty quantification","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"*After preprocessing overhead","category":"page"},{"location":"choosing_methods/#Detailed-Method-Selection","page":"Choosing Estimation Methods","title":"Detailed Method Selection","text":"","category":"section"},{"location":"choosing_methods/#Linear-Inversion-Methods","page":"Choosing Estimation Methods","title":"Linear Inversion Methods","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"When to use: High count experiments.","category":"page"},{"location":"choosing_methods/#LinearInversion","page":"Choosing Estimation Methods","title":"LinearInversion","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use for: Single state estimations or changing measurement setups\nAdvantages: Simple, robust, numerically stable\nLimitations: No uncertainty quantification, can produce unphysical states with low counts","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"method = LinearInversion()\nρ, θ = estimate_state(outcomes, measurement, method)","category":"page"},{"location":"choosing_methods/#PreAllocatedLinearInversion","page":"Choosing Estimation Methods","title":"PreAllocatedLinearInversion","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use for: Repeated tomography with the same measurement setup\nAdvantages: Significant speedup for batch processing, same accuracy as LinearInversion\nLimitations: Memory overhead, setup cost, inflexible to measurement changes","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"method = PreAllocatedLinearInversion()\n# Use same method instance for multiple estimations\nρ₁, θ₁ = estimate_state(outcomes₁, measurement, method)\nρ₂, θ₂ = estimate_state(outcomes₂, measurement, method)  # Much faster","category":"page"},{"location":"choosing_methods/#NormalEquations","page":"Choosing Estimation Methods","title":"NormalEquations","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use for: Measurements with many more POVM elements than parameters (M ≫ d²-1)\nAdvantages: Computational efficiency for overcomplete measurements\nLimitations: Less numerically stable, no benefit for moderately sized problems","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"method = NormalEquations()\nρ, θ = estimate_state(outcomes, measurement, method)","category":"page"},{"location":"choosing_methods/#Advanced-Methods","page":"Choosing Estimation Methods","title":"Advanced Methods","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"When to use: Low photon count experiments, single-photon tomography, or when statistical optimality/uncertainty is crucial.","category":"page"},{"location":"choosing_methods/#MaximumLikelihood","page":"Choosing Estimation Methods","title":"MaximumLikelihood","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use for: Photocount regime, optimal point estimates\nAdvantages: Handles Poisson statistics correctly, always produces physical states, asymptotically optimal\nLimitations: Slower than linear methods, no uncertainty quantification","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"method = MaximumLikelihood()\nρ, θ = estimate_state(outcomes, measurement, method;\n                      x₀=initial_guess,  # optional\n                      t=0.4,             # step size\n                      β=0.8)             # backtracking factor","category":"page"},{"location":"choosing_methods/#BayesianInference","page":"Choosing Estimation Methods","title":"BayesianInference","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use for: When uncertainty quantification is essential\nAdvantages: Full posterior distribution, natural error bars, handles any sample size\nLimitations: Very slow (orders of magnitude), requires careful prior selection","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"method = BayesianInference()\nρ, θ, Σ = estimate_state(outcomes, measurement, method;\n                         nsamples=10000,    # posterior samples\n                         nwarm=1000,        # burn-in period\n                         σ=1e-2)            # step size\n# Σ contains covariance matrix for error bars","category":"page"},{"location":"choosing_methods/#Measurement-Types","page":"Choosing Estimation Methods","title":"Measurement Types","text":"","category":"section"},{"location":"choosing_methods/#Standard-Measurements","page":"Choosing Estimation Methods","title":"Standard Measurements","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use when your POVM elements sum to identity: sum_m Pi_m = mathbb1","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"# Create measurement matrix directly\nmeasurement = assemble_measurement_matrix(povm_elements)","category":"page"},{"location":"choosing_methods/#Proportional-Measurements","page":"Choosing Estimation Methods","title":"Proportional Measurements","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use when measurements are incomplete or obstructed: sum_m Pi_m neq mathbb1","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"# Wrapper handles normalization issues automatically\nmeasurement = ProportionalMeasurement(povm_elements)","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Common scenarios:","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Spatial measurements with beam obstructions\nReduced measurement settings for efficiency\nIncomplete POVM implementations due to experimental constraints","category":"page"},{"location":"choosing_methods/#Practical-Guidelines","page":"Choosing Estimation Methods","title":"Practical Guidelines","text":"","category":"section"},{"location":"choosing_methods/#High-Throughput-Tomography","page":"Choosing Estimation Methods","title":"High-Throughput Tomography","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"For real-time or high-volume tomography:","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Use PreAllocatedLinearInversion for speed\nEnsure sufficient counts (>1000 per setting)\nValidate occasionally with MaximumLikelihood","category":"page"},{"location":"choosing_methods/#Low-counts:","page":"Choosing Estimation Methods","title":"Low counts:","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Always use MaximumLikelihood or BayesianInference\nConsider prior knowledge in Bayesian approach","category":"page"},{"location":"choosing_methods/#Benchmark/Validation-Studies","page":"Choosing Estimation Methods","title":"Benchmark/Validation Studies","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"For comparing methods or validating algorithms:","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Generate test data with Random States\nCompare computational efficiency vs accuracy trade-offs","category":"page"},{"location":"choosing_methods/#Debugging-Poor-Results","page":"Choosing Estimation Methods","title":"Debugging Poor Results","text":"","category":"section"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"If reconstruction fidelity is low:","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Check measurement informationally complete (matrix rank)\nVerify sufficient counts for chosen method\nConsider measurement calibration issues\nTry different estimation methods for comparison","category":"page"},{"location":"choosing_methods/","page":"Choosing Estimation Methods","title":"Choosing Estimation Methods","text":"Choose methods based on your experimental constraints, computational resources, and accuracy requirements. When in doubt, LinearInversion provides a robust starting point for high-count data, while MaximumLikelihood handles low-count scenarios effectively.","category":"page"},{"location":"random_states/#random_states","page":"Random State Generation","title":"Random State Generation","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"QuantumMeasurements.jl provides utilities for generating random quantum states and related mathematical objects. These are useful for testing tomography algorithms, benchmarking estimation methods, and simulating quantum systems.","category":"page"},{"location":"random_states/#Available-Random-Distributions","page":"Random State Generation","title":"Available Random Distributions","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"The package implements several important random distributions commonly used in quantum information:","category":"page"},{"location":"random_states/#Haar-Random-Unitaries","page":"Random State Generation","title":"Haar Random Unitaries","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"HaarUnitary generates random unitary matrices distributed according to the Haar measure, the unique unitarily invariant measure on the unitary group.","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"# Generate a single 3×3 Haar random unitary\nU = rand(HaarUnitary(3))\n\n# Generate multiple samples\nU_batch = rand(HaarUnitary(3), 4)  # 3×3×4 array","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"Implementation: Uses QR decomposition of complex Gaussian matrices with proper phase normalization to ensure uniform distribution on the unitary group.","category":"page"},{"location":"random_states/#Haar-Random-State-Vectors","page":"Random State Generation","title":"Haar Random State Vectors","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"HaarVector generates random pure quantum states (normalized complex vectors) distributed according to the induced Haar measure.","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"# Generate a random pure state in dimension 4\nψ = rand(HaarVector(4))\n\n# Multiple pure states\nψ_batch = rand(HaarVector(4), 100)  # 4×100 array","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"This corresponds to the first column of a Haar random unitary matrix.","category":"page"},{"location":"random_states/#Simplex-Sampling","page":"Random State Generation","title":"Simplex Sampling","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"Simplex generates random probability distributions (positive vectors that sum to 1) uniform on the probability simplex.","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"# Generate random probabilities for 5 outcomes\np = rand(Simplex(5))\nsum(p) ≈ 1  # true\n\n# Batch generation\np_batch = rand(Simplex(5), 50)  # 5×50 array","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"Algorithm: Uses the stick-breaking construction for uniform sampling on the simplex.","category":"page"},{"location":"random_states/#Random-Density-Matrices","page":"Random State Generation","title":"Random Density Matrices","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"The package provides two methods for generating random mixed quantum states:","category":"page"},{"location":"random_states/#Product-Measure","page":"Random State Generation","title":"Product Measure","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"ProductMeasure generates random density matrices by combining Haar random unitaries with uniform random eigenvalue distributions:","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"# Generate a random density matrix\nρ = rand(ProductMeasure(3))\n\n# Properties\ntr(ρ) ≈ 1         # normalized\nall(real.(eigvals(ρ)) .≥ 0)  # positive semidefinite","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"This measure factorizes as the product of the Haar measure on unitaries and the uniform (Lebesgue) measure on the probability simplex. It produces states with typically well-separated eigenvalues.","category":"page"},{"location":"random_states/#Ginibre-Ensemble","page":"Random State Generation","title":"Ginibre Ensemble","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"GinibreEnsamble generates random density matrices from the Ginibre ensemble - complex Gaussian random matrices normalized to unit trace:","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"# Generate using Ginibre ensemble  \nρ = rand(GinibreEnsamble(3))","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"Construction: Creates a complex Gaussian matrix G, then forms ρ = GG†/Tr(GG†).","category":"page"},{"location":"random_states/#Implementation-Notes","page":"Random State Generation","title":"Implementation Notes","text":"","category":"section"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"All random generators use ComplexF32 for memory efficiency while maintaining sufficient precision\nThe implementations are optimized for batch generation when multiple samples are needed\nRandom number generation respects @example's standard AbstractRNG interface for reproducibility","category":"page"},{"location":"random_states/","page":"Random State Generation","title":"Random State Generation","text":"These random state generators provide the foundation for comprehensive testing and validation of quantum tomography algorithms under realistic conditions.","category":"page"},{"location":"spatial_structure/#Spatial-structure-of-light","page":"Spatial structure of light","title":"Spatial structure of light","text":"","category":"section"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"This example demonstrates how to perform the tomography of the spatial structure of light. Although this is not necessarily quantum, the methods provided by QuantumMeasurements can be used to perform this task. For this example, we will also use the package StructuredLight.jl for the generation of the structured light patterns, as well as CairoMakie.jl for plotting.","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"using QuantumMeasurements, LinearAlgebra, StructuredLight, CairoMakie, Random\nRandom.seed!(1234);\nnothing #hide","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"One of the most well-known examples of structured light is the Laguerre-Gauss modes. These modes are solutions of the paraxial wave equation in cylindrical coordinates. They are characterized by two indices, p and l, the first one being the radial index, while the second one is the azimuthal index. We can generate these modes using the lg function from the StructuredLight package.","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"rs = LinRange(-3, 3, 256)\nϕ₁ = lg(rs, rs, p=1)\nϕ₂ = lg(rs, rs, l=2)\n\nvisualize(abs2.(cat(ϕ₁, ϕ₂, dims=3)))","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"We can now create a random superposition of these two modes.","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"ψs = randn(ComplexF64, 2)\nnormalize!(ψs)\nψ = ψs[1] * ϕ₁ + ψs[2] * ϕ₂\nprobs = abs2.(ψ)\nnormalize!(probs, 1)\nvisualize(probs)","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"What we want to do is recover the coefficients ψs from the image. We show now that this is equivalent to quantum state tomography.","category":"page"},{"location":"spatial_structure/#Theory","page":"Spatial structure of light","title":"Theory","text":"","category":"section"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"We first notice that the modes are normalized, i.e., int psi^2 dA = 1:","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"δA = step(rs)^2\n\nisapprox(sum(abs2, ϕ₁) * δA, 1, atol=1e-5) &&\nisapprox(sum(abs2, ϕ₂) * δA, 1, atol=1e-5) &&\nisapprox(sum(abs2, ψ) * δA, 1, atol=1e-5)","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"Therefore, we can regard psi^2 as a probability density function. The probability of making a detection in region R is given by","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"p(R) = int_R psi(mathbfr)^2 dA approx delta A times psi(mathbfr_R)^2","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"where mathbfr_R is any point in R and we have made the approximation that the region R is small enough that the mode can be considered constant. This is a reasonable approximation for pixels in a camera, for example. By expanding the mode in the basis phi_1 phi_2, we have","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"p(R)  sum_ij ψ_i^* ψ_j phi_i^*(mathbfr_R) phi_j(mathbfr_R) delta A = braketpsiphi_R^2","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"where phi_R = (phi_1^*(mathbfr_R)  phi_2^*(mathbfr_R)) times sqrtdelta A. We see then that the detection probability can be written as the Born rule for a projective measurement in phi_R.","category":"page"},{"location":"spatial_structure/#Tomography","page":"Spatial structure of light","title":"Tomography","text":"","category":"section"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"By having understood that this is a quantum state tomography problem, we can proceed to estimate the state. We assemble our measurement matrix:","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"μ = assemble_measurement_matrix([conj.(pair)...] * √δA for pair ∈ zip(ϕ₁, ϕ₂));\nnothing #hide","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"Finally, the measurements are simply the (normalized) intensity.","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"method = LinearInversion()\nρ = estimate_state(probs, μ, method)[1]","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"We can now compare the estimated state with the true state.","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"fidelity(ρ, ψs) ≈ 1","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"We see that the fidelity is close to 1, meaning that we have successfully recovered the state.","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"","category":"page"},{"location":"spatial_structure/","page":"Spatial structure of light","title":"Spatial structure of light","text":"This page was generated using Literate.jl.","category":"page"},{"location":"mathematical_foundations/#Mathematical-Foundations","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"This section provides the mathematical foundations of quantum state tomography that underpin the methods implemented in QuantumMeasurements.jl.","category":"page"},{"location":"mathematical_foundations/#Quantum-State-Tomography","page":"Mathematical Foundations","title":"Quantum State Tomography","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Let mathcalH be a Hilbert space of dimension d, and let mathrmHer(mathcalH) subset mathcalH be the set of Hermitian operators acting on mathcalH. The state of a quantum system is represented by an element rho of the set of positive semi-definite operators mathrmPos(mathcalH) subset mathrmHer(mathcalH) such that mathrmTr rho = 1. Quantum state tomography is the process of reconstructing the density operator rho from experimental data.","category":"page"},{"location":"mathematical_foundations/#Observables-and-Measurements","page":"Mathematical Foundations","title":"Observables and Measurements","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Observables are represented by elements A in mathrmHer(mathcalH), and their expectation values are given by:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"langle A rangle = mathrmTr left(rho Aright)","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"A Positive Operator Valued Measure (POVM) is a set of observables Pi_m subset mathrmPos(mathcalH) with the property that:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"sum_m Pi_m = mathbb1","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"where mathbb1 is the identity operator. These operators model the possible outcomes of an experiment: outcome m happens with probability p_m = mathrmTr left(Pi_m rho right) according to Born's rule. The POVM conditions ensure that p_m geq 0 and sum_m p_m = 1.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"A special case of a POVM is a projective measurement (PVM), where each Pi_m is a projector, i.e., Pi_m = u_mranglelangle u_m for some basis vector u_mrangle in mathcalH.","category":"page"},{"location":"mathematical_foundations/#Parameterization-of-States","page":"Mathematical Foundations","title":"Parameterization of States","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Usually, one chooses a specific basis for the Hilbert space mathcalH to represent the state rho, say u_1rangle ldots u_drangle. The density operator can then be expressed in terms of the basis vectors as:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"rho = sum_jk=1^d rho_jk u_jranglelangle u_k","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"where rho_jk = langle u_j  rho  u_k rangle are the matrix elements of rho in this basis.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Nonetheless, this matrix representation is redundant because rho is Hermitian and has unit trace. This means that only d^2 - 1 independent real parameters are needed to specify rho. We can choose a traceless basis of Hermitian operators to represent the state uniquely. A convenient choice is the generalized Gell-Mann matrices, which come in three types:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"beginaligned\nX_jk = fracu_jranglelangle u_k + u_kranglelangle u_jsqrt2 \nY_jk = fraci(u_jranglelangle u_k - u_kranglelangle u_j)sqrt2 \nZ_j = frac1sqrtj + j^2 left( sum_r=1^j u_rranglelangle u_r - j u_j+1ranglelangle u_j+1 right)\nendaligned","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"where j = 1 ldots d-1, k = j+1 ldots d, and u_1rangle ldots u_drangle is our chosen basis set of mathcalH. The type GellMannMatrices is an iterator over these matrices.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"We can specify any state rho by a list of real coefficients boldsymboltheta = (theta_1ldotstheta_d^2-1) such that:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"rho = rho(boldsymboltheta) = fracmathbb1d + sum_n=1^d^2-1 theta_n omega_n qquad (1)","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"where omega_n denotes one of the generalized Gell-Mann matrices. The vector boldsymboltheta is called the generalized Bloch vector. The Bloch vector can be calculated from the matrix rho using the function traceless_vectorization. Reciprocally, the density matrix can be reconstructed from the Bloch vector using density_matrix_reconstruction.","category":"page"},{"location":"mathematical_foundations/#linear_inversion","page":"Mathematical Foundations","title":"Linear Inversion estimator","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"By applying mathrmTr (Pi_m bullet) to both sides of equation (1), we arrive at the linear system:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"mathbfq = T boldsymboltheta","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"where q_m = p_m - mathrmTr Pi_m  d and T is a matrix with entries T_mn = mathrmTr left(Pi_m omega_n right).","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"If the matrix T is injective, the linear system has a unique solution given by:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"boldsymboltheta = (T^dagger T)^-1 T^daggerboldsymbolq qquad (2)","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"In this case, the POVM is said to be informationally complete. Otherwise, if T is not injective, the solution is no longer unique and the POVM is said to be informationally incomplete.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"This defines the simplest measurement type in our package: given an iterable representing a measurement (each element of the iterable must be a matrix representing the POVM element, or a vector. In the latter case, the vector is interpreted as a projector). Then one calls assemble_measurement_matrix to construct the matrix T. This is passed to the functions that perform the tomography.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"This would then be the simplest application of our package:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"itr = ... # an iterable of matrices or vectors representing the POVM elements\nprobs = ... # a vector of probabilities corresponding to the outcomes of the measurement\n\nμ = assemble_measurement_matrix(itr) # assemble the measurement matrix T\nρ, θ = estimate_state(probs, μ, LinearInversion()) # estimate the state (both the density matrix and the Bloch vector)","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"It is important to observe that the probabilities in the inversion formula (2) are not directly measurable and must be estimated. The simplest method substitutes them with observed experimental frequencies hatp_m = N_m  N, where N_m is the number of times outcome m was observed and N = sum_m N_m is the total number of observations. This estimation of the probabilities is inherently noisy, due to finite number of observations or experimental imperfections, which can lead to inaccuracies in the reconstructed state. Most importantly, it might be the case that the state reconstructed from the estimated probabilities is not a valid density matrix, i.e., it may not be positive semi-definite. Therefore, the estimate_state function will apply an algorithm to project the reconstructed state onto the closest valid density matrix [2], ensuring that the output is always a valid quantum state.","category":"page"},{"location":"mathematical_foundations/#Other-estimation-Methods","page":"Mathematical Foundations","title":"Other estimation Methods","text":"","category":"section"},{"location":"mathematical_foundations/#Variants-of-Linear-Inversion","page":"Mathematical Foundations","title":"Variants of Linear Inversion","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"While the basic linear inversion approach provides a straightforward solution to quantum state tomography, different computational strategies can be employed depending on the specific requirements of the problem. The package implements three variants of linear inversion, each with distinct advantages and trade-offs.","category":"page"},{"location":"mathematical_foundations/#LinearInversion","page":"Mathematical Foundations","title":"LinearInversion","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"The standard LinearInversion method solves the linear system T boldsymboltheta = boldsymbolq directly using QR decomposition via Julia's \\ operator. This is the most straightforward implementation that solves the system without explicitly computing matrix inverses.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Theory: The method solves the linear system T boldsymboltheta = boldsymbolq directly using QR decomposition, which provides a numerically stable least-squares solution for overdetermined systems.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Motivation: This approach is ideal for single-shot tomography or when the measurement setup changes between different state estimations. It requires no preprocessing and is numerically stable due to the QR decomposition.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Pros: ","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Simple and robust implementation\nNo memory overhead for preprocessing\nNumerically stable via QR decomposition\nSuitable for one-time or infrequent state estimations","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Cons:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Computational overhead for repeated estimations with the same measurement\nSlower than optimized variants for multiple estimations","category":"page"},{"location":"mathematical_foundations/#PreAllocatedLinearInversion","page":"Mathematical Foundations","title":"PreAllocatedLinearInversion","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"The PreAllocatedLinearInversion method precomputes the pseudoinverse T^+ of the measurement matrix during initialization, storing it for subsequent state estimations. This eliminates the need to solve the linear system repeatedly.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Theory: By precomputing T^+, the state estimation reduces to a simple matrix-vector multiplication: boldsymboltheta = T^+ boldsymbolq, where boldsymbolq is adjusted for the trace part.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Motivation: This variant is designed for scenarios where many state estimations are performed using the same measurement setup, such as real-time tomography.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Pros:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Significant speedup for repeated estimations\nPredictable computational cost per estimation\nOptimal for batch processing or real-time applications","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Cons:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Memory overhead for storing the precomputed pseudoinverse\nRequires reinitialization if the measurement setup changes\nInitial setup cost for computing the pseudoinverse","category":"page"},{"location":"mathematical_foundations/#NormalEquations","page":"Mathematical Foundations","title":"NormalEquations","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"The NormalEquations method solves the normal equations T^dagger T boldsymboltheta = T^dagger boldsymbolq directly, which can be computationally advantageous when the number of measurements is much larger than the number of parameters.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Theory: Instead of computing the pseudoinverse, this method forms the normal equations explicitly: (T^dagger T) boldsymboltheta = T^dagger boldsymbolq. The system matrix is square and typically smaller than the original overdetermined system.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Motivation: For measurements with a large number of POVM elements (large M) relative to the Hilbert space dimension, solving the normal equations can be more efficient than direct pseudoinverse computation.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Pros:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Efficient for overcomplete measurements (large M relative to d^2-1)\nReduced computational complexity in high-redundancy scenarios\nLower memory requirements during computation","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Cons:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Potentially less numerically stable than QR-based methods\nCan amplify numerical errors if T^dagger T is ill-conditioned\nMay not provide advantages for moderately sized problems","category":"page"},{"location":"mathematical_foundations/#Choosing-the-Right-Variant","page":"Mathematical Foundations","title":"Choosing the Right Variant","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"The choice between these variants depends on the specific use case:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Use LinearInversion for single estimations or when numerical stability is paramount\nUse PreAllocatedLinearInversion when performing many estimations with the same measurement setup\nUse NormalEquations when dealing with highly redundant measurements where M gg d^2-1","category":"page"},{"location":"mathematical_foundations/#Advanced-Estimation-Methods","page":"Mathematical Foundations","title":"Advanced Estimation Methods","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Beyond linear inversion, the package provides advanced methods for challenging experimental scenarios:","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Maximum Likelihood Estimation: Optimal for low photon count experiments and single-photon tomography. Handles Poisson statistics correctly and always produces physical states.\nBayesian Inference: Provides full uncertainty quantification through posterior distributions. Computationally intensive but optimal for scenarios requiring error bars and handling of prior knowledge.","category":"page"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"For guidance on selecting the appropriate method for your experimental conditions, see Choosing Estimation Methods.","category":"page"},{"location":"mathematical_foundations/#See-Also","page":"Mathematical Foundations","title":"See Also","text":"","category":"section"},{"location":"mathematical_foundations/","page":"Mathematical Foundations","title":"Mathematical Foundations","text":"Maximum Likelihood Estimation: Advanced method for low photon counts\nBayesian Inference: Full posterior estimation with uncertainty quantification  \nProportional Measurements: Handling incomplete measurements\nRandom States: Generating test data for validation\nChoosing Estimation Methods: Practical guide for method selection","category":"page"},{"location":"proportional_measurements/#prop_meas","page":"Proportional Measurements","title":"Proportional Measurements","text":"","category":"section"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Proportional measurements arise when the experimental setup cannot implement a complete POVM, or when the POVM is not properly normalized. Instead, we can only specify a set of positive operators Pi_m such that the probability of measuring outcome m is proportional to mathrmTr(rho Pi_m), but the normalization may be state-dependent or unknown. This scenario occurs in several important contexts:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Incomplete measurement settings: When only a subset of a complete POVM can be measured\nObstructed detection: When physical obstructions block part of the measurement\nExperimental constraints: When measurement apparatus limitations prevent complete projective measurements","category":"page"},{"location":"proportional_measurements/#Mathematical-Framework","page":"Proportional Measurements","title":"Mathematical Framework","text":"","category":"section"},{"location":"proportional_measurements/#The-Proportionality-Problem","page":"Proportional Measurements","title":"The Proportionality Problem","text":"","category":"section"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Consider a set of positive operators Pi_m where sum_m Pi_m neq mathbb1. The measurement yields outcomes with probabilities:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"p_m = fracmathrmTr(rho Pi_m)mathrmTr(rho G)","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"where G = sum_m Pi_m is the total measurement operator. The denominator depends on the unknown state rho, creating a normalization problem.","category":"page"},{"location":"proportional_measurements/#Transformation-to-Valid-POVM","page":"Proportional Measurements","title":"Transformation to Valid POVM","text":"","category":"section"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"The ProportionalMeasurement type solves this by transforming the problem into standard tomography. The key insight is to:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Compute the Kraus operator: Find A such that A^dagger A = G using Cholesky decomposition\nTransform measurement operators: Define tildePi_m = A^-dagger Pi_m A^-1\nTransform the state: Work with the transformed state tilderho = A rho A^dagger  mathrmTr(rho G)","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"This transformation ensures sum_m tildePi_m = mathbb1, creating a valid POVM for the transformed state.","category":"page"},{"location":"proportional_measurements/#Implementation-Details","page":"Proportional Measurements","title":"Implementation Details","text":"","category":"section"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"The ProportionalMeasurement constructor automatically handles this transformation:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"# Create from operators that don't form a complete POVM\noperators = [π₁, π₂, ..., πₘ]  # where sum(operators) ≠ I\nμ = ProportionalMeasurement(operators)\n\n# Use with any estimation method\nρ_est = estimate_state(outcomes, μ, method)[1]","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"The implementation:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Computes G = sum(operators) and its Cholesky decomposition\nStores the Kraus operator and its inverse for efficient transformations\nAutomatically applies the inverse transformation during state reconstruction","category":"page"},{"location":"proportional_measurements/#Applications-and-Examples","page":"Proportional Measurements","title":"Applications and Examples","text":"","category":"section"},{"location":"proportional_measurements/#Reduced-Measurement-Settings","page":"Proportional Measurements","title":"Reduced Measurement Settings","text":"","category":"section"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Some experiments use minimal measurement settings for practical reasons. For example, the twin-photon example uses only 16 polarization measurement combinations instead of the complete 36-setting tomography.","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Advantage: Faster data collection with fewer experimental configurations Trade-off: Requires proportional measurement analysis instead of direct POVM inversion","category":"page"},{"location":"proportional_measurements/#When-to-Use-Proportional-Measurements","page":"Proportional Measurements","title":"When to Use Proportional Measurements","text":"","category":"section"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Use proportional measurements when:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Complete POVM implementation is experimentally challenging\nPhysical obstructions are unavoidable\nMeasurement time must be minimized","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Limitations:","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"Slightly reduced precision compared to complete measurements\nComputational overhead for Kraus transformations\nRequires careful handling of numerical stability in matrix inversions","category":"page"},{"location":"proportional_measurements/","page":"Proportional Measurements","title":"Proportional Measurements","text":"The ProportionalMeasurement framework provides a solution for quantum tomography in realistic experimental conditions where ideal complete measurements are not feasible.","category":"page"},{"location":"quick_start/#Quick-start","page":"Quick-Start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"In this tutorial, we will lay down the first steps necessary to perform quantum state tomography. We will learn how to specify what measurement was made, how to represent the experimental results, and finally, how to actually get an estimation of the density operator that produced such experimental results. As an example, we will perform the tomography of the polarization state of a single photon.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Assuming that the package has been installed, we start by running","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"using QuantumMeasurements","category":"page"},{"location":"quick_start/#Specifying-our-measurement","page":"Quick-Start","title":"Specifying our measurement","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"We now need to specify the polarization basis in which the measurements are performed. In this case, we have chosen the horizontal (H), vertical (V), diagonal (D), anti-diagonal (A), right circular (R), and left circular (L) polarization states. This is run by calling","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"measurement_basis = [polarization_state(s) / √3 for s ∈ (:H, :V, :D, :A, :R, :L)]","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The polarization_state function returns the polarization state corresponding to the symbol s. These are simply two-dimensional complex vectors representing the polarization states. We normalize these states by a factor of √3 to ensure that our set forms a Projective Valued Measure (PVM). For more information on this, check the Mathematical Foundations section of the documentation.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"We then assemble a measurement matrix corresponding to this basis by calling assemble_measurement_matrix:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"μ = assemble_measurement_matrix(measurement_basis)","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This matrix has the property that, given a Bloch vector boldsymboltheta that represents a state rho, the probability of obtaining the outcome i is given by p_i = sum_j mu_ij theta_j. This is the representation of our measurement that will be used to estimate the state.","category":"page"},{"location":"quick_start/#Specifying-our-measurement-results","page":"Quick-Start","title":"Specifying our measurement results","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The experimental outcomes are represented by a vector of integers. The order corresponds to the one defined by the measurement basis. In this case, we had 100 detections for the H projection, 0 detections for the V projection, and 50 detections for each of the remaining four projections. This is represented by the vector","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"outcomes = [100, 0, 50, 50, 50, 50]","category":"page"},{"location":"quick_start/#Performing-the-tomography","page":"Quick-Start","title":"Performing the tomography","text":"","category":"section"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Now that we have specified our measurement and the experimental outcomes, we can proceed to perform the quantum state tomography.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"First, we choose a tomography method. In this tutorial, we will use the simplest one, the LinearInversion. We create an instance of this method:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"method = LinearInversion()","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"Finally, we call estimate_state to get an estimate of the state:","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"ρ = estimate_state(outcomes, μ, method)[1]","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"The output of this code is the estimated density operator rho that produced the experimental outcomes. We index the output with [1] because the function estimate_state returns a tuple with the estimated state and the corresponding Bloch vector. In this case, we are only interested in the estimated state.","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"","category":"page"},{"location":"quick_start/","page":"Quick-Start","title":"Quick-Start","text":"This page was generated using Literate.jl.","category":"page"},{"location":"twin_photons_pvm/#Twin-Photons","page":"Twin Photons","title":"Twin Photons","text":"","category":"section"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"In this example, we perform the tomography of the polarization state of a pair of twin photons. The photons are generated from SPDC and are entangled in polarization.","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"We will first load up a few packages. We use CSV.jl (you might need to install it) in order to read the real experimental data.","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"using CSV, LinearAlgebra, QuantumMeasurements","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"We then read the experimental data, which is located in the examples directory of the repository.","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"dir = pkgdir(QuantumMeasurements);\npath = joinpath(dir, \"examples\", \"counts.csv\");\nfile = CSV.File(path, header=false);\nnothing #hide","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"The following code translates the contents of the file to a form that will be useful to us.","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"This is just a function to parse a string into a complex number","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"parse_c(s) = parse(ComplexF32, s);\nnothing #hide","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"The outcomes are contained in row 4, and we normalize to get frequencies","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"outcomes = [Float32(parse_c(row[4])) for row in file]\nfreqs = normalize(outcomes, 1);\nnothing #hide","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"These are the coefficients defining the measurement, which are coincidence counts after the beam gets projected into a pair of polarization states","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"These vectors define the polarization projector for each of the two detectors","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"ψ1 = [[parse_c(row[5]), parse_c(row[6])] for row ∈ file]\nψ2 = [[parse_c(row[7]), parse_c(row[8])] for row ∈ file];\nnothing #hide","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"We now assemble the projectors on the two-photon state using kron. We divide by 3 to ensure that the sum of the PVM projectors is the identity matrix.","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"pvm = [kron(pair...) / 3 for pair in zip(ψ1, ψ2)];\nnothing #hide","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"The measurement matrix is assembled:","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"μ = assemble_measurement_matrix(pvm);\nnothing #hide","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"Finally, we choose the MaximumLikelihood method and make our estimation:","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"method = MaximumLikelihood()\nρ_pred = estimate_state(freqs, μ, method)[1]","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"We can see that we are very close to the Bell state, which was the desired outcome of the experiment:","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"ψ = [1 + 0im, 0, 0, 1] / √2\nfidelity(ψ, ρ_pred) ≥ 0.99","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"","category":"page"},{"location":"twin_photons_pvm/","page":"Twin Photons","title":"Twin Photons","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bayesian_inference/#Bayesian-Inference","page":"Bayesian Inference","title":"Bayesian Inference","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Bayesian inference addresses limitations of both linear inversion and maximum likelihood estimation. While linear inversion can produce unphysical states and MLE yields point estimates without uncertainty quantification, Bayesian methods provide posterior distributions that incorporate uncertainty and prior knowledge.","category":"page"},{"location":"bayesian_inference/#Theory-and-Motivation","page":"Bayesian Inference","title":"Theory and Motivation","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Bayesian Mean Estimation (BME) computes a posterior distribution over all possible states and reports the posterior mean as the estimate [4]:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"hatrho_textBME = int rho  pi(rho  mathcalD)  drho","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"where pi(rho  mathcalD) is the posterior distribution given data mathcalD. According to Bayes' rule:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"pi(rho  mathcalD) = fracmathcalL(mathcalD  rho) pi_0(rho)mathcalZ","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Here, mathcalL(mathcalD  rho) is the likelihood function, pi_0(rho) is the prior distribution, and mathcalZ is the normalization constant.","category":"page"},{"location":"bayesian_inference/#The-Prior-Distribution","page":"Bayesian Inference","title":"The Prior Distribution","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"The choice of prior pi_0(rho) is both a strength and limitation of Bayesian inference. The prior encodes assumptions about the quantum state before observing data, which can be valuable when genuine prior knowledge exists (e.g., from physical constraints or previous experiments).","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Default Choice: The package uses a uniform prior in the Bloch vector representation by default (log_prior=θ -> zero(...)), which corresponds to a flat distribution over the traceless part of the density matrix. This choice is uninformative and lets the data dominate the posterior.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Arbitrariness Concern: The prior choice is inherently subjective and can influence results, particularly with limited data. Different reasonable priors may yield different estimates. However, as the amount of data increases, the prior's influence diminishes and the posterior concentrates around the maximum likelihood estimate.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Robustness: For informationally complete measurements with sufficient data, Bayesian estimates become relatively insensitive to prior choice. The likelihood function dominates the posterior, making the method practically robust despite the theoretical arbitrariness.","category":"page"},{"location":"bayesian_inference/#Key-Properties","page":"Bayesian Inference","title":"Key Properties","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Full-Rank States: BME never produces zero eigenvalues. The posterior mean incorporates uncertainty, ensuring all eigenvalues remain positive for reasonable priors.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Uncertainty Quantification: The posterior covariance matrix provides error bars. Each parameter's uncertainty can be computed from the posterior distribution.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Optimal Performance: Under proper scoring rules, BME minimizes the expected loss for operationally meaningful distance measures between quantum states.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Small Sample Performance: BME handles limited datasets by incorporating prior knowledge and regularization through posterior averaging.","category":"page"},{"location":"bayesian_inference/#Implementation:-MALA-Algorithm","page":"Bayesian Inference","title":"Implementation: MALA Algorithm","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"The package implements Bayesian inference using the Metropolis-Adjusted Langevin Algorithm (MALA), an MCMC method that samples from the posterior distribution.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"MALA proposes new states using the gradient of the log-posterior:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"theta_textprop = theta_textcurrent + fracsigma^22 nabla log pi(theta_textcurrent  mathcalD) + sigma epsilon","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"where epsilon sim mathcalN(0 I) is Gaussian noise and sigma controls the step size.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Each proposal is accepted with probability:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"alpha = minleft(1 fracpi(theta_textprop  mathcalD)pi(theta_textcurrent  mathcalD) times fracq(theta_textcurrent  theta_textprop)q(theta_textprop  theta_textcurrent)right)","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"where q(theta  theta) is the proposal distribution probability density for transitioning from state theta to theta. In MALA, this follows a multivariate Gaussian distribution centered at the gradient-adjusted current state. The ratio fracq(theta_textcurrent  theta_textprop)q(theta_textprop  theta_textcurrent) corrects for the asymmetry introduced by the gradient-based proposals, ensuring detailed balance and proper sampling from the posterior.","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Implementation Features:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Adaptive Step Size: The algorithm adjusts sigma to target 57.4% acceptance rate\nConstraint Handling: Proposals leading to non-positive matrices are rejected\nWarm-up Phase: Initial burn-in period for chain convergence","category":"page"},{"location":"bayesian_inference/#Computational-Cost","page":"Bayesian Inference","title":"Computational Cost","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Warning: Bayesian inference is computationally expensive, requiring orders of magnitude more time than linear inversion or MLE. Typical runs require thousands of MCMC samples, each involving gradient computations and matrix operations. This method should be used when uncertainty quantification justifies the computational overhead.","category":"page"},{"location":"bayesian_inference/#Usage","page":"Bayesian Inference","title":"Usage","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"method = BayesianInference()\n\nρ_est, θ_est, Σ = estimate_state(outcomes, μ, method; \n                                 nsamples=10000,                    # Posterior samples\n                                 nwarm=1000,                        # Warm-up iterations\n                                 σ=1e-2,                           # Initial step size\n                                 log_prior=θ -> zero(eltype(θ)))    # Prior function","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Parameters:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"nsamples: Number of MCMC samples to collect from posterior\nnwarm: Number of warm-up iterations for chain equilibration\nσ: Initial step size parameter (automatically adapted)\nlog_prior: Function specifying the log-prior density\nθ₀: Initial Bloch vector (default: maximally mixed state)\nchain: Optional matrix to store the full MCMC chain","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Output:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"ρ_est: Posterior mean density matrix\nθ_est: Posterior mean Bloch vector  \nΣ: Posterior covariance matrix (uncertainty quantification)","category":"page"},{"location":"bayesian_inference/#When-to-Use-Bayesian-Inference","page":"Bayesian Inference","title":"When to Use Bayesian Inference","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Use Bayesian inference when:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Uncertainty quantification is required\nWorking with limited data where other methods fail\nParameter correlations are important\nComputational cost is acceptable relative to accuracy requirements","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"For routine tomography or when computational speed is important, consider linear inversion or MLE instead. See Choosing Estimation Methods for detailed guidance.","category":"page"},{"location":"bayesian_inference/#Relationship-to-Other-Methods","page":"Bayesian Inference","title":"Relationship to Other Methods","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Bayesian inference represents the most complete statistical approach:","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"vs Linear Inversion: Handles any sample size, provides uncertainty quantification\nvs Maximum Likelihood Estimation: Full posterior vs point estimate, incorporates prior knowledge\nCost: Significantly higher computational expense","category":"page"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"The method is recommended when the additional computational cost is justified by the need for rigorous uncertainty analysis or when working in the challenging regime of very limited experimental data.","category":"page"},{"location":"bayesian_inference/#See-Also","page":"Bayesian Inference","title":"See Also","text":"","category":"section"},{"location":"bayesian_inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Mathematical Foundations: Basic theory and linear inversion methods  \nMaximum Likelihood Estimation: Optimal point estimation for low counts\nChoosing Estimation Methods: Practical guide for method selection\nRandom States: Generating test data for validation","category":"page"},{"location":"twin_photons_prop/#Twin-photons-with-proportional-measurement","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"","category":"section"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"In this example, we perform a similar tomography as in Twin Photons. The difference is that, now, the measurement performed is not a PVM. The data from this example was taken from [1]","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"We load the necessary packages and define our polarization states","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"using LinearAlgebra, QuantumMeasurements\n\nh = polarization_state(:H)\nv = polarization_state(:V)\nd = polarization_state(:D)\na = polarization_state(:A)\nr = polarization_state(:R)\nl = polarization_state(:L);\nnothing #hide","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"The main difference arises here, in the specification of our measurement:","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"projectors = [kron(h, h),\n    kron(h, v),\n    kron(v, v),\n    kron(v, h),\n    kron(r, h),\n    kron(r, v),\n    kron(d, v),\n    kron(d, h),\n    kron(d, r),\n    kron(d, d),\n    kron(r, d),\n    kron(h, d),\n    kron(v, d),\n    kron(v, l),\n    kron(h, l),\n    kron(r, l),];\nnothing #hide","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"Notice that the sum of the corresponding projectors is not even proportional to the identity matrix:","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"sum(x -> x * x', projectors)","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"Therefore, this measurement is not a PVM/POVM.","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"As discussed in [1], this occurred because of experimental ease: This measurement only contains 16 settings (the minimum amount), as opposed to the 36 settings present in the Twin Photons example. Notice, also, that only one of the polarization states changes between each successive measurement, so that only one set of wave plates needs to be adjusted.","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"To deal with this kind of situation, we can build a ProportionalMeasurement:","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"μ = ProportionalMeasurement(projectors);\nnothing #hide","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"The theory behind this is better explained at Proportional Measurements.","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"From now on, everything follows the standard procedure.","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"We specify the experimental outcomes","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"outcomes = [34749, 324, 35805, 444, 16324, 17521, 13441,\n    16901, 17932, 32028, 15132, 17238, 13171, 17170, 16722, 33586];\nnothing #hide","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"We define our tomography method and make our prediction","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"method = MaximumLikelihood()\nρ_pred = estimate_state(outcomes, μ, method)[1]","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"Once again, we aim to be close to a Bell state:","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"ψ = [1 + 0im, 0, 0, 1] / √2\n0.96 ≤ fidelity(ρ_pred, ψ) ≤ 0.97","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"","category":"page"},{"location":"twin_photons_prop/","page":"Twin photons with proportional measurement","title":"Twin photons with proportional measurement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Measurements","page":"API","title":"Measurements","text":"","category":"section"},{"location":"api/#Measurement-interface","page":"API","title":"Measurement interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The methods in this section forms the interface for measurements. The user can implement their own measurements by following the interface.","category":"page"},{"location":"api/#QuantumMeasurements.ProportionalMeasurement-Tuple{Any}","page":"API","title":"QuantumMeasurements.ProportionalMeasurement","text":"ProportionalMeasurement(itr)\n\nConstructs a proportional measurement from the iterator itr.\n\nThis measurement is proportional in the sense that, given Given μ = ProportionalMeasurement(itr)  and a Bloch vector θ, the probabilities of the outcomes are proportional to μ.measurement_matrix * θ\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.empty_measurement-Union{Tuple{T}, Tuple{Any, Any, Type{T}}} where T<:(AbstractMatrix)","page":"API","title":"QuantumMeasurements.empty_measurement","text":"empty_measurement(num_outcomes, dim, T)\n\nReturns an empty measurement matrix with num_outcomes outcomes and dimension dim.\n\nThe type T should be either an AbstractMatrix or a ProportionalMeasurement(@ref).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.filter_measurement-Tuple{AbstractMatrix, Any}","page":"API","title":"QuantumMeasurements.filter_measurement","text":"filter_measurement(μ, J)\n\nFilters the measurement μ so that only the outcomes J are represented.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_dim-Tuple{AbstractMatrix}","page":"API","title":"QuantumMeasurements.get_dim","text":"get_dim(μ)\n\nReturns the dimension of the measurement μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_measurement_type-Tuple{AbstractMatrix}","page":"API","title":"QuantumMeasurements.get_measurement_type","text":"get_measurement_type(μ)\n\nReturns the type of the measurement μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_num_outcomes-Tuple{AbstractMatrix}","page":"API","title":"QuantumMeasurements.get_num_outcomes","text":"get_num_outcomes(μ)\n\nReturns the number of possible outcomes for a single trial of measurement μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_probabilities!-Tuple{Any, AbstractMatrix, Any}","page":"API","title":"QuantumMeasurements.get_probabilities!","text":"get_probabilities!(dest, μ, θ)\n\nReturns the probabilities of the outcomes of the measurement μ given the coefficients θ. The result is stored in dest.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_probabilities-Tuple{Any, Any}","page":"API","title":"QuantumMeasurements.get_probabilities","text":"get_probabilities(μ, θ)\n\nReturns the probabilities of the outcomes of the measurement μ given the coefficients θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_trace_part-Tuple{AbstractMatrix}","page":"API","title":"QuantumMeasurements.get_trace_part","text":"get_trace_part(μ)\n\nReturns the trace part of the measurement μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.get_traceless_part-Tuple{AbstractMatrix}","page":"API","title":"QuantumMeasurements.get_traceless_part","text":"get_traceless_part(μ)\n\nReturns the traceless part of the measurement μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.multithreaded_update_measurement!-Tuple{AbstractMatrix, Vararg{Any, 4}}","page":"API","title":"QuantumMeasurements.multithreaded_update_measurement!","text":"multithreaded_update_measurement!(μ, buffers, itr, pars, f!)\n\nSame as update_measurement!(@ref), but uses multithreading.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.post_estimation_routine!-Tuple{Any, Any, Any}","page":"API","title":"QuantumMeasurements.post_estimation_routine!","text":"post_estimation_routine!(ρ, θ, μ)\n\nPerforms a post-estimation routine on the state ρ, θ for the measurement μ. Default implementation does nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.update_measurement!-Tuple{AbstractMatrix, Any}","page":"API","title":"QuantumMeasurements.update_measurement!","text":"update_measurement!(μ, itr)\nupdate_measurement!(μ::AbstractMatrix, buffer, itr, pars, f!)\n\nUpdates the measurement μ with an iterator itr. The second sigature is used when the measurement is updated with a buffer and a function f!, which is used to update the buffer. f! should have the signature f!(buffer, pars).\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"If get_measurement_type, get_num_outcomes and get_probabilities! are implemented, one has also access to get_probabilities:","category":"page"},{"location":"api/#QuantumMeasurements.get_probabilities","page":"API","title":"QuantumMeasurements.get_probabilities","text":"get_probabilities(μ, θ)\n\nReturns the probabilities of the outcomes of the measurement μ given the coefficients θ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-matrix","page":"API","title":"Measurement matrix","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The simplest measurement type is just a matrix:","category":"page"},{"location":"api/#QuantumMeasurements.assemble_measurement_matrix-Tuple{Any}","page":"API","title":"QuantumMeasurements.assemble_measurement_matrix","text":"assemble_measurement_matrix(itr)\n\nAssembles a measurement matrix from an iterator itr. Each row of the matrix is a vectorization of the corresponding element of itr. vectorization is implemented when the element of itr is a matrix or a vector, representing a Positive Operator Valued Measure (POVM) or a Projection Valued Measure (PVM) respectively. Given μ = assemble_measurement_matrix(itr) and a Bloch vector θ, the probabilities of the outcomes are calculated by μ * θ\n\n\n\n\n\n","category":"method"},{"location":"api/#Proportional-Measurements","page":"API","title":"Proportional Measurements","text":"","category":"section"},{"location":"api/#QuantumMeasurements.ProportionalMeasurement","page":"API","title":"QuantumMeasurements.ProportionalMeasurement","text":"ProportionalMeasurement(itr)\n\nConstructs a proportional measurement from the iterator itr.\n\nThis measurement is proportional in the sense that, given Given μ = ProportionalMeasurement(itr)  and a Bloch vector θ, the probabilities of the outcomes are proportional to μ.measurement_matrix * θ\n\n\n\n\n\n","category":"type"},{"location":"api/#Tomography-Methods","page":"API","title":"Tomography Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This package contains several methods for quantum state tomography. They should be passed to the following function in order to perform the tomography:","category":"page"},{"location":"api/#QuantumMeasurements.estimate_state","page":"API","title":"QuantumMeasurements.estimate_state","text":"estimate_state(outcomes, μ, method; kwargs...)\n\nEstimate the state of a quantum system given the outcomes of a set of measurements represented by μ using the specified method.\n\nIf outcomes is an array of integers, it is interpreted as the number of times each measurement outcome was observed. If outcomes is an array of floats, it is interpreted as the frequency of each measurement outcome, so the sum of the elements must be 1.\n\nOutputs a tuple (ρ, θ) where ρ is the estimated density matrix and θ is the corresponding Bloch vector. Additionally, the BayesianInference method also returns a covariance matrix Σ  representing the uncertainty in the estimated Bloch vector.\n\nFor AbstractLinearInversion (LinearInversion, PreAllocatedLinearInversion and NormalEquations) methods,  there are no additional keyword arguments.\n\nFor the MaximumLikelihood method, the following keyword arguments are available:\n\nx₀=zeros(get_measurement_type(μ), get_dim(μ)^2 - 1): Initial guess for the Bloch vector. Default is a maximally mixed state.\nt=0.4: Initial step size for the backtracking line search.\nβ=0.8: Factor for the backtracking line search.\nmax_iter=10^3: Maximum number of iterations.\ntol=1e-10: Tolerance for the convergence criterion.\n\nFor the BayesianInference method, the following keyword arguments are available:\n\nverbose=false: whether to print information about the run.\nσ=get_measurement_type(μ)(1e-2): the initial standard deviation of the proposal distribution.\nlog_prior=θ -> zero(get_measurement_type(μ)): the log-prior function.\nθ₀=zeros(get_measurement_type(μ), get_dim(μ)^2 - 1): the initial state of the chain.\nnsamples=10^4: the number of samples to take.\nnwarm=10^3: the number of warm-up samples to take.\nchain=nothing: if not nothing, store the chain in this matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The available methods are:","category":"page"},{"location":"api/#QuantumMeasurements.LinearInversion","page":"API","title":"QuantumMeasurements.LinearInversion","text":"LinearInversion <: AbstractLinearInversion\n\nA type representing a linear inversion method for estimating the state of a quantum system. The equations are solved by a QR decomposition (\\ operator).\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.PreAllocatedLinearInversion","page":"API","title":"QuantumMeasurements.PreAllocatedLinearInversion","text":"PreAllocatedLinearInversion(μ) <: AbstractLinearInversion\n\nCreate a PreAllocatedLinearInversion instance for the given measurement μ.\n\nThis method precomputes the pseudo-inverse of the corresponding measurement matrix, so that subsequent calls to estimate_state are faster.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.NormalEquations","page":"API","title":"QuantumMeasurements.NormalEquations","text":"NormalEquations(μ) <: AbstractLinearInversion\n\nCreate a NormalEquations instance for the given measurement μ. This method solves the normal equations for the given measurement matrix. This can be faster for systems with a large number of measurements.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.MaximumLikelihood","page":"API","title":"QuantumMeasurements.MaximumLikelihood","text":"MaximumLikelihood\n\nA type used to specify the maximum likelihood estimation method.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.BayesianInference","page":"API","title":"QuantumMeasurements.BayesianInference","text":"BayesianInference\n\nCreate a Bayesian inference instance.\n\nThis method is passed to the estimate_state method in order to perform quantum state tomography.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gell-Mann-Matrices","page":"API","title":"Gell-Mann Matrices","text":"","category":"section"},{"location":"api/#QuantumMeasurements.GellMannMatrices","page":"API","title":"QuantumMeasurements.GellMannMatrices","text":"GellMannMatrices(dim, ::Type{T}=ComplexF32) where {T<:Complex}\n\nIterator over the generalized Gell-Mann matrices of dimension dim with elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#Vectorization","page":"API","title":"Vectorization","text":"","category":"section"},{"location":"api/#QuantumMeasurements.traceless_vectorization","page":"API","title":"QuantumMeasurements.traceless_vectorization","text":"traceless_vectorization(A)\n\nReturns a vector θ containing the projections of A onto the GellMannMatrices.  A can be a matrix or a vector. In the latter case, it is treated as a projector. The vector θ has length dim^2 - 1, where dim is the dimension of A.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumMeasurements.traceless_vectorization!","page":"API","title":"QuantumMeasurements.traceless_vectorization!","text":"traceless_vectorization!(θ, A)\n\nSame as traceless_vectorization, but stores the result in θ.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumMeasurements.density_matrix_reconstruction","page":"API","title":"QuantumMeasurements.density_matrix_reconstruction","text":"density_matrix_reconstruction(θ)\n\nReturns the density matrix corresponding to the Bloch vector θ.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumMeasurements.density_matrix_reconstruction!","page":"API","title":"QuantumMeasurements.density_matrix_reconstruction!","text":"density_matrix_reconstruction!(ρ, θ)\n\nSame as density_matrix_reconstruction, but stores the result in ρ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Generation-of-Random-States","page":"API","title":"Generation of Random States","text":"","category":"section"},{"location":"api/#QuantumMeasurements.GinibreEnsamble","page":"API","title":"QuantumMeasurements.GinibreEnsamble","text":"GinibreEnsamble(dim::Int)\n\nA type representing a Ginibre ensamble of complex matrices of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.HaarUnitary","page":"API","title":"QuantumMeasurements.HaarUnitary","text":"HaarUnitary(dim::Int)\n\nA type representing a Haar-random unitary matrix of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.HaarVector","page":"API","title":"QuantumMeasurements.HaarVector","text":"HaarVector(dim::Int)\n\nA type representing a Haar-random unitary vector of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.ProductMeasure","page":"API","title":"QuantumMeasurements.ProductMeasure","text":"ProductMeasure(dim::Int)\n\nA type representing a measure on the density states. It is a product Haar measure on the unitary group and a uniform (Lebesgue) measure on the simplex.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumMeasurements.Simplex","page":"API","title":"QuantumMeasurements.Simplex","text":"Simplex(dim::Int)\n\nA type representing a random point on the simplex embeded in a space of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, HaarUnitary, Integer}","page":"API","title":"Base.rand","text":"Base.rand([rng = default_rng()], type, [n_samples])\n\nSample n_samples from type.\n\nIf n_samples is not provided, a single sample is returned.\n\nPossible values for type are HaarUnitary, HaarVector, Simplex, ProductMeasure, and GinibreEnsamble.\n\n\n\n\n\n","category":"method"},{"location":"api/#Misc","page":"API","title":"Misc","text":"","category":"section"},{"location":"api/#LinearAlgebra.isposdef!-Tuple{Any, Any}","page":"API","title":"LinearAlgebra.isposdef!","text":"isposdef!(ρ, xs, set)\n\nCalculate the linear combination of the elements of set with the coefficients xs and check if the result is a positive definite matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.fidelity-Tuple{AbstractMatrix, AbstractMatrix}","page":"API","title":"QuantumMeasurements.fidelity","text":"fidelity(ρ, σ)\n\nCalculate the fidelity between two quantum states.\n\nEither state can be pure or mixed, and represented by vectors or matrices, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.fisher-Tuple{AbstractMatrix, Any}","page":"API","title":"QuantumMeasurements.fisher","text":"fisher(μ, θs)\n\nReturns the Fisher information matrix for the measurement μ and the state decribed by a Bloch vector θs.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.polarization_state-Union{Tuple{Symbol}, Tuple{T}, Tuple{Symbol, Type{T}}} where T","page":"API","title":"QuantumMeasurements.polarization_state","text":"polarization_state(s::Symbol, ::Type{T}=ComplexF32) where {S, T}\n\nReturn the polarization state corresponding to the symbol S as a vector of type T. S can be one of the following symbols:\n\n:H for horizontal polarization\n:V for vertical polarization\n:D for diagonal polarization\n:A for antidiagonal polarization\n:R for right-handed circular polarization\n:L for left-handed circular polarization\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.project2density!-Tuple{Any}","page":"API","title":"QuantumMeasurements.project2density!","text":"project2density(ρ)\n\nProject a Hermitian matrix ρ to a density matrix by setting the negative eigenvalues to zero and normalizing the trace to 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.project2pure-Tuple{Any}","page":"API","title":"QuantumMeasurements.project2pure","text":"project2pure(ρ)\n\nProject a Hermitian matrix ρ to a pure state by returning the eigenvector corresponding to the largest eigenvalue.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumMeasurements.simulate_outcomes-NTuple{4, Any}","page":"API","title":"QuantumMeasurements.simulate_outcomes","text":"simulate_outcomes([rng,] state, measurement, N; atol=1e-4)\n\nSimulate the outcomes of a measurement measurement on a state state N times. The rng parameter is a random number generator. state can be either a vector, describing a pure state, or a matrix, describing a mixed state. atol is the absolute tolerance for the sum of the probabilities to be 1.  If the tolerance is not met, an error is thrown, which probably means that there is something wrong with the provided state or measurement.\n\n\n\n\n\n","category":"method"},{"location":"maximum_likelihood/#Maximum-Likelihood-Estimation","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"For situations with limited observations (e.g., photocount regime), the maximum likelihood estimator (MLE) is more appropriate than linear inversion. While linear inversion relies on frequency estimates that become unreliable with few observations, MLE works directly with the count data.","category":"page"},{"location":"maximum_likelihood/#Theory-and-Motivation","page":"Maximum Likelihood Estimation","title":"Theory and Motivation","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"The maximum likelihood estimator seeks the density operator that maximizes the probability of observing the experimental data:","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"hatrho_ML = argmax_rho mathcalL(N_1 ldots N_M  rho)","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"where the likelihood function for count data is:","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"mathcalL(N_1 ldots N_M  rho) = prod_m=1^M leftmathrmTr left(Pi_m rho right)right^N_m","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Here, N_m represents the number of times outcome m was observed in the experiment, and the total number of observations is N = sum_m N_m.","category":"page"},{"location":"maximum_likelihood/#Key-Advantages","page":"Maximum Likelihood Estimation","title":"Key Advantages","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Statistical Optimality: MLE is asymptotically efficient, meaning it achieves the Cramér-Rao bound for large sample sizes, providing the best possible precision given the available data.","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Finite Sample Performance: Unlike linear inversion, which can produce unphysical results (non-positive matrices) when probabilities are poorly estimated from few counts, MLE directly optimizes over valid density operators, ensuring physical outputs.","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Photocount Compatibility: MLE naturally handles scenarios with discrete photon counts, making it ideal for single-photon experiments and quantum optics applications where the Poisson statistics of detection events matter.","category":"page"},{"location":"maximum_likelihood/#Implementation-Details","page":"Maximum Likelihood Estimation","title":"Implementation Details","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"The package implements MLE using the Accelerated Projected Gradient (APG) algorithm with adaptive restart, following the approach of [3]. The optimization procedure:","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Parameterization: The density operator is parameterized using the Bloch vector representation to ensure the trace condition mathrmTr(rho) = 1.\nPositivity Constraint: During optimization, each step checks if the resulting state remains positive semi-definite. If not, the step is rejected and a smaller step size is used.\nConvergence: The algorithm continues until the gradient norm falls below a specified tolerance or the maximum number of iterations is reached.","category":"page"},{"location":"maximum_likelihood/#Usage","page":"Maximum Likelihood Estimation","title":"Usage","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"method = MaximumLikelihood()\n\nρ_est, θ_est = estimate_state(outcomes, μ, method;\n                              x₀=zeros(d²-1),     # Initial Bloch vector\n                              t=0.4,              # Initial step size  \n                              β=0.8)              # Backtracking factor","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Parameters:","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"x₀: Initial guess for the Bloch vector (default: maximally mixed state)\nt: Initial step size for backtracking line search\nβ: Reduction factor for backtracking line search","category":"page"},{"location":"maximum_likelihood/#When-to-Use-MLE","page":"Maximum Likelihood Estimation","title":"When to Use MLE","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"MLE is particularly recommended for:","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Low photon count experiments (N < 1000 per measurement setting)\nSingle-photon tomography where Poisson noise dominates\nHigh-precision applications where statistical optimality is crucial\nScenarios where physical constraints must be strictly enforced","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"For large sample sizes, linear inversion becomes computationally more efficient and produces similar results. For practical guidance on when to use each method, see Choosing Estimation Methods.","category":"page"},{"location":"maximum_likelihood/#Relationship-to-Other-Methods","page":"Maximum Likelihood Estimation","title":"Relationship to Other Methods","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"MLE provides a middle ground between Linear Inversion and full Bayesian Inference:","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"vs Linear Inversion: More robust for small samples, always produces physical states\nvs Bayesian Inference: Faster computation, but no uncertainty quantification","category":"page"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"For quantum tomography applications, MLE represents the gold standard for point estimation when computational resources are limited but statistical rigor is required.","category":"page"},{"location":"maximum_likelihood/#See-Also","page":"Maximum Likelihood Estimation","title":"See Also","text":"","category":"section"},{"location":"maximum_likelihood/","page":"Maximum Likelihood Estimation","title":"Maximum Likelihood Estimation","text":"Mathematical Foundations: Basic theory and linear inversion methods\nBayesian Inference: Full posterior estimation with uncertainty quantification\nChoosing Estimation Methods: Practical guide for method selection","category":"page"},{"location":"#QuantumMeasurements.jl-Documentation","page":"Home","title":"QuantumMeasurements.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for QuantumMeasurements.jl, a comprehensive Julia package for quantum state tomography. This documentation will guide you through everything from basic usage to advanced theoretical foundations.","category":"page"},{"location":"#What-is-QuantumMeasurements.jl?","page":"Home","title":"What is QuantumMeasurements.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumMeasurements.jl reconstructs quantum states from experimental measurement data using statistically rigorous methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key Capabilities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiple estimation algorithms from fast linear methods to full Bayesian inference.\nFlexible measurement handling including incomplete and obstructed measurements.\nUncertainty quantification with proper error bars and confidence intervals.","category":"page"},{"location":"#Quick-Navigation","page":"Home","title":"Quick Navigation","text":"","category":"section"},{"location":"#**Getting-Started**","page":"Home","title":"🚀 Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"New to quantum state tomography or the package? Start here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation: Get the package running\nQuick Start Guide: Basic polarization tomography example\nExamples: Practical applications","category":"page"},{"location":"#**Theory-and-Methods**","page":"Home","title":"📚 Theory and Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Understand the mathematics and choose the right approach:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mathematical Foundations: Core theory and linear methods\nMaximum Likelihood Estimation: Optimal point estimation\nBayesian Inference: Full uncertainty quantification\nProportional Measurements: Handling incomplete measurements","category":"page"},{"location":"#**Practical-Guides**","page":"Home","title":"🛠 Practical Guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Application-focused resources for real experiments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Choosing Estimation Methods: Decision guide for your experimental setup\nRandom State Generation: Testing and validation utilities","category":"page"},{"location":"#**Reference**","page":"Home","title":"📖 Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Complete technical reference:","category":"page"},{"location":"","page":"Home","title":"Home","text":"API Documentation: All functions, types, and parameters\nReferences: Scientific citations and further reading","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumMeasurements.jl is not registered in the Julia General Registry (someone has already taken the name). Nonetheless, it can be easily installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/marcsgil/QuantumMeasurements.jl\")","category":"page"},{"location":"#Supported-Julia-Versions","page":"Home","title":"Supported Julia Versions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia 1.10 and later versions.","category":"page"},{"location":"#First-Steps","page":"Home","title":"First Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once installed, try the Quick Start Guide for a hands-on introduction, or explore the Examples to see the package in action with real experimental scenarios.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For questions about which method to use for your specific application, the Choosing Estimation Methods guide provides practical decision-making guidance.","category":"page"},{"location":"obstructed_spatial_structure/#Spatial-structure-of-light-with-obstructions","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"","category":"section"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"This example is similar to Spatial structure of light, but now we will introduce an obstruction in the spatial structure of light. This will demonstrate how the tomography can still be performed even when the spatial structure is not fully accessible.","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"We will use the same packages as before:","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"using QuantumMeasurements, LinearAlgebra, StructuredLight, CairoMakie, Random\nRandom.seed!(1234);\nnothing #hide","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"We now generate the Laguerre-Gauss modes as before, but we will introduce an obstruction in the spatial structure of light. The obstruction will be a horizontal barrier that blocks the light in the middle of the image. In the code, this is achieved by introducing coordinates xs that only cover the right half of the image (x > 0), and ys that cover the full height:","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"xs = LinRange(0, 3, 128)\nys = LinRange(-3, 3, 256)","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"We generate the Laguerre-Gauss modes as before, but now using the new coordinates:","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"ϕ₁ = lg(xs, ys, p=1)\nϕ₂ = lg(xs, ys, l=2)\n\nvisualize(abs2.(cat(ϕ₁, ϕ₂, dims=3)))","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"We can now create a random superposition of these two modes, as before:","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"ψs = randn(ComplexF64, 2)\nnormalize!(ψs)\nψ = ψs[1] * ϕ₁ + ψs[2] * ϕ₂\nprobs = abs2.(ψ)\nnormalize!(probs, 1)\nvisualize(probs)","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"Now, we use a ProportionalMeasurement to perform the tomography to define our measurement, since, now, it is no longer a PVM (Projection Valued Measure) due to the obstruction. This measurement type already takes care of the logic of the obstruction, and performs the necessary normalization. For that reason, we no longer need to multiply by δA (the area of the pixel), as in the previous example. Take a look at the Proportional Measurements documentation for more details.","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"μ = ProportionalMeasurement([conj.(pair)...] for pair ∈ zip(ϕ₁, ϕ₂))","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"Finally, everything is the same as before, we can estimate the state using the LinearInversion method.","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"method = LinearInversion()\nρ = estimate_state(probs, μ, method)[1]","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"We can now compare the estimated state with the true state. The fidelity should be close to 1, meaning that we have successfully recovered the state.","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"fidelity(ρ, ψs) ≈ 1","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"","category":"page"},{"location":"obstructed_spatial_structure/","page":"Spatial structure of light with obstructions","title":"Spatial structure of light with obstructions","text":"This page was generated using Literate.jl.","category":"page"}]
}
